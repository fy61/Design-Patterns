# 设计模式

## 基石：面向接口编程

## 创建型

**核心思想：** 把创造对象的过程藏起来，让你的主程序（你的手）不需要知道如何捏泥巴、如何烧窑，只需要告诉工厂（创造者）“我要一个茶杯”就行。

创建型模式的核心是**“隔离变化”**，即把创建对象的复杂过程和变化点从主业务逻辑中隔离出来，让程序更灵活。

| **模式名称**                       | 12312123123132         | **解决的问题**                                               | **生活示例**                                                 |
| ---------------------------------- | ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **1. 单例模式 (Singleton)**        | **“地球只有一个总统”** | 保证某个东西在整个程序运行期间**只有一个**，避免资源浪费和冲突。 | 公司的**配置中心**（所有人都必须读取同一份设置）；你家的**路由器**（全局唯一，管理所有网络）。 |
| **2. 工厂方法 (Factory Method)**   | **“分工明确的生产线”** | 客户端（你）只管下订单，具体的**创建逻辑交给子工厂**去完成。如果你要生产汽车，就找汽车工厂。 | 你想喝咖啡，告诉**咖啡机**（抽象工厂），它为你生产**美式**（具体产品），而生产美式的逻辑藏在美式咖啡的子类中。 |
| **3. 抽象工厂 (Abstract Factory)** | **“系列产品定制店”**   | 让你一次性创建**一整套**相互关联的产品。                     | **家装套餐**：你选“现代简约风”套餐，它自动为你配齐（沙发、桌子、灯具）一整套都是现代简约风格的产品。 |
| **4. 建造者 (Builder)**            | **“乐高积木拼装师”**   | 用**一步一步**的方法来创建复杂的对象，避免构造函数参数太多。 | 制作一个复杂的**汉堡**：先放面包片、再放肉饼、再放生菜... 每一步都是独立的，但最终顺序决定了成品。 |
| **5. 原型 (Prototype)**            | **“复印机”**           | 通过**克隆或复制**一个现有的对象来创建新对象，比重新创建一个要快得多。 | 制作一份合同，你只需要拿出一份模板（原型），然后**复制**一份，再修改几个字就行了。 |

### Singleton（单例模式）

**模式意图**

- 保证一个类仅有一个实例，并提供一个全局访问点

**应用场景**

- 配置类、日志管理器、线程池、数据库连接池等需要全局唯一对象。

**小结**

单例模式确保全局唯一实例。使用 `volatile + synchronized` 可以防止多线程下重复创建实例。

### Factory Method（工厂方法模式）

- 模式意图
  - 定义一个创建对象的接口，让子类决定实例化哪一个类。
- 小结
  - 工厂方法模式通过“继承 + 多态”封装对象创建逻辑，让代码更符合“开闭原则”。

### Abstract Factory（抽象工厂模式）

- 模式意图

  - 提供一个接口，用于创建一系列相关或依赖对象，而无需指定它们的具体类。

- 应用场景

  - UI 组件系统（不同主题下按钮和输入框搭配）

    数据库访问层（MySQL / Oracle 工厂）



### Builder（建造者模式）

- 模式意图

  - 将复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。

- 应用场景

  - 复杂对象有多个可选参数（如建造房屋、组装电脑）。

    构造函数参数太多时。

    

### Prototype（原型模式）

- 模式意图

  - 通过复制现有对象来创建新对象，而不是通过 `new` 关键字

- 应用场景

  - 对象创建开销大（例如加载复杂数据）。

    需要保留对象状态，但又希望产生独立副本。

原型模式通过浅/深拷贝来快速复制对象状态，避免了复杂初始化的性能开销。





## 结构型

**核心思想**：
 结构型模式关注 **类与对象的组合方式**，
 通过灵活的结构实现 **复用、扩展与解耦**。

关注于如何巧妙地把现有的一些零件（类或对象）**组合**起来，形成一个更大、功能更强的新结构。

结构型模式的核心是**“优化结构”**，通过巧妙的组合或包装，让现有代码更灵活、更容易扩展，同时减少冗余和复杂性。

| **模式名称**              | 12312123123132             | **解决的问题**                                               | **生活示例**                                                 |
| ------------------------- | -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **6. 适配器 (Adapter)**   | **“万能插头”**             | 将一个旧接口（老插头）转换成一个新接口（新插座）能接受的格式，让不兼容的组件可以一起工作。 | 你的旧电脑只有 VGA 接口，但新显示器只有 HDMI，你需要一个 **VGA-HDMI 适配器**。 |
| **7. 装饰器 (Decorator)** | **“美图秀秀滤镜”**         | **动态地**给一个对象添加新的功能，像穿衣服一样，不改变对象本身。 | 你的照片（原始对象）可以**动态**地加上“美颜滤镜”、“边框”或“贴纸”（装饰），而照片文件本身不用重做。 |
| **8. 代理 (Proxy)**       | **“中介或经纪人”**         | 为另一个对象提供一个**替身**或占位符，由替身来控制对原对象的访问。 | **明星的经纪人**：你不能直接联系明星，必须通过经纪人（代理）来做预约、审核等前置工作。 |
| **9. 外观 (Facade)**      | **“一键启动面板”**         | 为复杂的子系统提供一个**简单的统一入口**，用户不需要关心底层复杂的交互细节。 | **汽车仪表盘**：你按下一个“启动”按钮，底层涉及发动机、电路、油路的复杂检查都被这个按钮（外观）隐藏了。 |
| **10. 桥接 (Bridge)**     | **“遥控器与电视机的分离”** | 把一个大类拆分成两个可以**独立变化**的部分，减少子类的数量。 | 电视机（抽象）和遥控器（实现）可以独立升级：换个新电视，旧遥控器可能还能用；换个万能遥控器，老电视也能用。 |
| **11. 组合 (Composite)**  | **“套娃或文件夹结构”**     | 把**个体**和**群体**看作同一种对象，用户可以统一处理它们。   | **电脑的文件系统**：你可以复制一个文件（个体），也可以复制一个文件夹（群体），操作方式是一样的。 |
| **12. 享元 (Flyweight)**  | **“共享单车”**             | 当需要创建大量类似对象时，将它们的**不变部分**共享出来，以节省内存。 | 城市里的**共享单车**：虽然有上万辆，但所有单车的“车锁结构”、“品牌 Logo”都是一样的（共享元），只有“编号”是变的。 |

### 适配器模式（Adapter Pattern）

- 适配器模式用于将 **一个类的接口转换成客户端期望的另一个接口**，
   使得原本由于接口不兼容而不能一起工作的类可以协同工作。
- 适配器模式在「旧接口与新接口」之间架起桥梁，非常适用于系统升级或兼容旧代码的场景。



### 装饰者模式（Decorator Pattern）

- 装饰者模式在 **不改变原有类结构** 的前提下，
   **动态地扩展对象的功能**。

  > 类比：给咖啡加糖、加奶，不改咖啡本身结构。

- 装饰者模式通过组合而非继承来扩展功能。
   它是 **开放封闭原则（OCP）** 的典型实现



### 代理模式（Proxy Pattern）

- 代理模式为某对象提供一个 **代理对象** 来控制对它的访问。

  - 远程代理（RPC）

    缓存代理

    权限控制

    延迟加载

- > 代理模式常用于性能优化或安全控制。
  > 可在访问前后执行额外逻辑（如缓存、鉴权、日志）。



### 外观模式（Facade Pattern）

- 外观模式为复杂系统提供一个 **统一的接口**，
   隐藏系统内部复杂的子模块调用逻辑。

  > 类比：酒店前台统一帮你安排订房、叫车、送餐。

- 外观模式简化了接口使用，对外暴露统一入口点。
   适用于封装复杂子系统或提供统一服务网关。



### 桥接模式（Bridge Pattern）

- 桥接模式将 **抽象部分** 与 **实现部分** 分离，使它们可以独立变化。
   适用于需要在多个维度变化的场景（如设备类型 × 操作系统）。

-  **小结：**

  > 桥接模式避免了多层继承的组合爆炸问题，
  > 在多维度变化的系统中（如设备类型 × 控制方式）尤为重要。



### 组合模式（Composite Pattern）

- 组合模式将对象组合成 **树形结构**，使得单个对象和组合对象的使用具有一致性。
   常见于文件系统、组织架构、菜单结构。

- **小结：**

  > 组合模式让树形结构中的节点与叶子具备统一操作接口，
  > 非常适合层级结构（如目录、组织架构）。



### 享元模式（Flyweight Pattern）

- **概念**

  享元模式通过 **共享对象** 来减少内存使用，
   适合大量相似对象的场景（如文字渲染、棋盘、游戏地图）。

-  **小结：**

  > 享元模式在对象数量庞大时节省内存。
  > 关键在于提取「可共享状态（内部状态）」与「不可共享状态（外部状态）」。

## 行为型

**核心思想：** 关注对象之间如何沟通、如何分配任务，让程序中的各个部分能够高效地协同工作。

行为型模式的核心是**“优化协作”**，它让对象间的通信更有组织、更灵活，从而使系统的功能模块更容易扩展和维护。

|               **模式名称**               |     123213123123123      | **解决的问题**                                               | **生活示例**                                                 |
| :--------------------------------------: | :----------------------: | ------------------------------------------------------------ | ------------------------------------------------------------ |
|        **13. 观察者 (Observer)**         |   **“微信公众号订阅”**   | 当一个对象的**状态发生变化**时，自动通知所有依赖它的对象。   | 你关注了天气预报公众号（主题），它一发布“台风警报”，所有订阅者（观察者）都会收到。 |
|         **14. 策略 (Strategy)**          |     **“算法选择器”**     | 将一系列不同的算法（策略）封装起来，可以**随时替换**使用不同的算法。 | **收银台的折扣算法**：你可以随时切换“满减”、“会员价”或“节日折扣”策略，但收银台的逻辑（使用策略）不变。 |
|    **15. 模板方法 (Template Method)**    |  **“做菜食谱的主步骤”**  | 定义好一个算法的**固定步骤框架**，但把具体实现细节交给子类去完成。 | **做蛋糕的食谱**：步骤是固定的（混合面粉、烘烤、装饰），但“装饰”的具体步骤（子类）可以千变万化。 |
| **16. 责任链 (Chain of Responsibility)** |    **“公司请假流程”**    | 将请求沿着一条**链条**传递，直到链上的某个对象能够处理这个请求为止。 | 员工请假：先找组长批、组长不行找经理批、经理不行找总经理批。**权限不同，按序处理。** |
|        **17. 迭代器 (Iterator)**         | **“电视遥控器的上下键”** | 提供一种统一的方式来**遍历**一个集合中的所有元素，而不需要知道集合底层的复杂结构（是数组还是链表）。 | 你在看一个相册，按“下一张”键就能依次查看所有照片，不用知道这些照片在硬盘上是怎么存储的。 |
|          **18. 命令 (Command)**          |    **“遥控器的按钮”**    | 将一个**请求**封装成一个独立的对象，以便实现请求的撤销、重做、排队等功能。 | 遥控器上的“播放”、“暂停”按钮：每个按钮封装了一个具体的命令，当你按下它时，命令对象被执行。 |
|           **19. 状态 (State)**           |       **“红绿灯”**       | 对象的行为会根据它的**内部状态**改变而改变，对象看起来好像改变了它的类。 | **红绿灯**：灯处于“红灯”状态时，你不能走；处于“绿灯”状态时，你可以走。灯的状态改变，你的行为也跟着改变。 |
|         **20. 备忘录 (Memento)**         |      **“游戏存档”**      | 在不破坏对象封装性的前提下，安全地保存一个对象的**历史状态**，以便将来可以恢复。 | 玩游戏时，你在关键节点**存档**（备忘录），失败了可以随时恢复到存档时的状态。 |
|        **21. 中介者 (Mediator)**         |      **“机场塔台”**      | 定义一个中心对象，负责协调多个对象之间的复杂交互，减少对象间的直接依赖。 | **机场塔台**：飞机之间不需要直接通信，都通过塔台（中介者）进行协调，避免空中交通混乱。 |
|       **22. 解释器 (Interpreter)**       |       **“翻译官”**       | 为一种语言定义一个文法（规则），并用解释器来解释句子。       | **计算器**：它解释你输入的数学表达式（如 1 + 2 * 3）的语法，并算出结果。 |
|         **23. 访问者 (Visitor)**         |      **“体检医生”**      | 在不改变对象结构的前提下，为对象添加新的操作（访问者）。     | **工厂质检员**：他不需要修改每台机器（被访问者）的结构，只需要根据自己的专业（访问者）对每台机器进行不同的检查和操作。 |

### 策略模式（Strategy Pattern）

- 概念

  定义一系列算法，把它们一个个封装起来，并使它们可以相互替换。
   **策略模式**让算法的变化独立于使用算法的客户端。

  > 类比：出行策略可以是“开车”、“坐地铁”、“骑车”，随时切

- **小结：**

  > 策略模式让算法独立于调用者，便于灵活切换不同算法实现。
  > 常用于支付方式、排序算法、权限校验等。



###  观察者模式（Observer Pattern）

- 概念

  定义对象间一对多的依赖关系，当一个对象状态改变时，
   所有依赖它的对象都会自动收到通知。

  > 类比：微信公众号推送机制。

- **小结：**

  > 观察者模式在事件驱动系统中非常常见，如消息推送、监听器、Spring 事件机制等。

### 命令模式（Command Pattern）

- ### 概念

  将“请求”封装成对象，从而可以参数化不同请求、排队、撤销操作。

  > 类比：遥控器按键可配置不同命令（开灯、关灯、调光）

- **小结：**

  > 命令模式将操作与调用者解耦，使得命令可被撤销、排队或记录。
  > 常见于事务日志、任务队列、UI 按钮事件。

### 状态模式（State Pattern）

- **概念**

  允许对象在内部状态改变时，改变它的行为。

  > 类比：播放器在“播放”、“暂停”、“停止”状态下行为不同。

- **小结：**

  > 状态模式让状态逻辑内聚在状态类中，避免 if-else 冗余。
  > 常用于订单、工作流、UI 控件等状态驱动系统。

### 责任链模式（Chain of Responsibility Pattern）

- **概念**

  将请求沿着一条链传递，直到有对象处理它。
   避免请求发送者与接收者的耦合。

  > 类比：请假流程，逐级审批。

- **小结：**

  > 责任链模式让请求的发送者与处理者解耦，动态组合处理流程。
  > 常见于权限校验、拦截器链、异常处理机制

### 中介者模式（Mediator Pattern）

- 意图

  > **用一个中介对象封装一系列对象之间的交互，避免对象间的直接引用，使系统松耦合。**

- **总结：**

  > 适合在**多对象交互复杂**的系统中使用（如聊天室、航班调度、UI 控件协调）。
  > 优点是**解耦对象依赖**，但中介者本身可能变得复杂。



### 访问者模式（Visitor Pattern）

- **意图**

  > **在不改变对象结构的前提下，为对象结构增加新操作。**

- **总结：**

  > 当需要对一组对象执行多种操作时非常有用（如报表、导出、统计）。
  > 缺点是结构固定，对象层级变化不方便。



### 备忘录模式（Memento Pattern）

- 意图

  > **在不破坏封装的前提下，捕获对象的内部状态，并在之后恢复它。**

- **总结：**

  > 常见于**撤销/回滚**功能。
  > 注意不要暴露对象内部细节，最好用内部类封装



### 迭代器模式（Iterator Pattern）

- 意图

  > **提供一种方法顺序访问聚合对象中的元素，而不暴露其内部结构。**

- **总结：**

  > 使用迭代器可隐藏内部结构，简化集合遍历逻辑。
  > Java 的 `Iterator` 与 `Iterable` 接口即该模式的实现。



### 解释器模式（Interpreter Pattern）

- 意图

  > **定义一个语言的语法表示，并建立一个解释器来解释该语言中的句子。**

- **总结：**